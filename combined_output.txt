
--- controllers\attachmentController.js ---
// controllers/attachmentController.js
const Attachment = require('../models/Attachment');
const fs = require('fs').promises;
const path = require('path');
const { validationResult } = require('express-validator');
const logger = require('../utils/logger');
const { processImage } = require('../middlewares/upload');
const sanitize = require('mongo-sanitize');

exports.uploadAttachmentGeneral = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      if (req.file) await fs.unlink(req.file.path);
      return res.status(400).json({ errors: errors.array() });
    }

    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    // Additional sanitization
    const type = sanitize(req.body.type);
    const foreign_key_id = sanitize(req.body.foreign_key_id);

    if (req.file.mimetype.startsWith('image/')) {
      await processImage(req.file.path);
    }

    const stats = await fs.stat(req.file.path);
    
    const attachment = new Attachment({
      type,
      foreign_key_id,
      file_url: `/uploads/${req.file.filename}`,
      uploaded_by: req.user._id,
      mime_type: req.file.mimetype,
      file_size: stats.size
    });

    await attachment.save();
    
    logger.info(`Attachment uploaded: ${attachment._id}`, {
      user: req.user._id,
      type: attachment.type
    });

    return res.status(201).json({
      message: 'Attachment uploaded',
      attachmentId: attachment._id,
      file_url: attachment.file_url
    });

  } catch (err) {
    if (req.file) await fs.unlink(req.file.path).catch(() => {});
    logger.error(`Upload error: ${err.message}`, { error: err });
    return res.status(500).json({ error: 'Server error' });
  }
};

exports.getAttachment = async (req, res) => {
  try {
    const attachmentId = sanitize(req.params.attachmentId);
    const attachment = await Attachment.findById(attachmentId)
      .lean()
      .setOptions({ sanitizeFilter: true });

    if (!attachment) {
      return res.status(404).json({ error: 'Attachment not found' });
    }

    // Set security headers
    res.set({
      'Content-Security-Policy': "default-src 'none'",
      'X-Content-Type-Options': 'nosniff',
      'Cross-Origin-Resource-Policy': 'same-site'
    });

    return res.json({ attachment });

  } catch (err) {
    logger.error(`Fetch error: ${err.message}`, { error: err });
    return res.status(500).json({ error: 'Server error' });
  }
};

exports.deleteAttachment = async (req, res) => {
  try {
    const attachmentId = sanitize(req.params.attachmentId);
    const attachment = await Attachment.findOne({
      _id: attachmentId,
      uploaded_by: req.user._id
    });

    if (!attachment) {
      return res.status(404).json({ error: 'Attachment not found' });
    }

    const filePath = path.join(__dirname, '..', attachment.file_url);
    await fs.unlink(filePath).catch(err => {
      logger.warn(`File delete warning: ${err.message}`);
    });

    await Attachment.deleteOne({ _id: attachmentId });
    
    logger.info(`Attachment deleted: ${attachmentId}`, {
      user: req.user._id
    });

    return res.json({ message: 'Attachment deleted' });

  } catch (err) {
    logger.error(`Delete error: ${err.message}`, { error: err });
    return res.status(500).json({ error: 'Server error' });
  }
};

--- controllers\authController.js ---
// controllers/authController.js
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const User = require('../models/User');

exports.registerUser = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' });
    }

    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    const user = new User({
      name,
      email,
      password: hashedPassword
    });
    await user.save();

    return res.status(201).json({ message: 'User registered successfully' });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};

exports.loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const match = await bcrypt.compare(password, user.password);
    if (!match) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { userId: user._id, email: user.email },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN }
    );

    console.log(token);

    // Set HttpOnly cookie WITH DOMAIN
    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production', // Use secure cookies in production
      sameSite: 'lax', // Prevent CSRF attacks
      maxAge: 24 * 60 * 60 * 1000, // Cookie expiry (24 hours) - adjust as needed
      path: '/', // Cookie available for the entire site
      domain: '.golockedin.com', // ADD THIS LINE:  Set the domain for cross-subdomain access
    });

    console.log(token);
    console.log(res);

    return res.json({ message: 'Login successful' }); // Don't send the token in the response body
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};

exports.logoutUser = (req, res) => {
  res.clearCookie('token', {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    path: '/',
    domain: '.golockedin.com', // Ensure domain is cleared as well
  });
  res.status(200).json({ message: 'Logged out successfully' });
};

--- controllers\bidController.js ---
const Bid = require('../models/Bid');
const Gig = require('../models/Gig');
const { getIO } = require('../utils/socketIOInstance');
const Notification = require('../models/Notification')
const Conversation = require('../models/Conversation');
const Message = require('../models/Message');

exports.createBid = async (req, res) => {
  console.log('hid');
  try {
    const { gig_id, amount, message } = req.body;
    const userId = req.user.userId;

    // Check if the user has already placed a bid on this gig
    const existingBid = await Bid.findOne({ gig_id, user_id: userId });
    if (existingBid) {
      return res.status(400).json({ error: 'You have already placed a bid on this gig.' });
    }

    const gig = await Gig.findById(gig_id).populate('user_id');
    if (!gig) {
      return res.status(404).json({ error: 'Gig not found' });
    }

    // Create a new bid
    const newBid = new Bid({
      gig_id,
      user_id: userId,
      amount,
      message,
    });
    await newBid.save();

    // Create a new conversation
    const newConversation = new Conversation({
      gig_id,
      gig_owner_id: gig.user_id._id,
      bidder_id: userId,
      bid_id: newBid._id,
    });
    await newConversation.save();

    // Add the conversation ID to the bid
    newBid.conversation_id = newConversation._id;
    await newBid.save();

    // Create the initial message in the conversation
    const initialMessage = new Message({
      conversation_id: newConversation._id,
      sender_id: userId,
      content: message,
    });
    await initialMessage.save();

    // Create a notification for the gig owner
    const notification = new Notification({
      user_id: gig.user_id._id,
      type: 'bid',
      message: `You have a new bid of $${amount} on your gig: ${gig.title}`,
      link: `/gig/${gig_id}`,
    });
    await notification.save();

    // Emit the notification to the gig owner via Socket.IO
    const io = getIO();
    io.to(gig.user_id._id.toString()).emit('newNotification', notification);

    res.status(201).json({ message: 'Bid placed successfully', newBid });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// Only the gig owner sees all bids; non-owner sees only their own
exports.getBidsForGig = async (req, res) => {
  try {
    const { gigId } = req.params;
    const userId = req.user.userId;

    const gig = await Gig.findById(gigId);
    if (!gig) {
      return res.status(404).json({ error: 'Gig not found' });
    }

    if (gig.user_id.toString() === userId) {
      // Gig owner sees all bids with full user details
      const bids = await Bid.find({ gig_id: gigId })
        .populate('user_id', 'name profile_pic_url rating');
      return res.json(bids);
    } else {
      // Non-owner sees only their own bid with full details
      const yourBid = await Bid.findOne({ gig_id: gigId, user_id: userId })
        .populate('user_id', 'name profile_pic_url rating');
      if (!yourBid) return res.json([]);
      return res.json([yourBid]);
    }
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};

// Accept a bid (gig owner only)
exports.acceptBid = async (req, res) => {
  try {
    const { bidId } = req.params;
    const userId = req.user.userId;
    const bid = await Bid.findById(bidId).populate('gig_id');
    if (!bid) return res.status(404).json({ error: 'Bid not found' });

    if (bid.gig_id.user_id.toString() !== userId) {
      return res.status(403).json({ error: 'Only gig owner can accept bids' });
    }

    // Mark bid as accepted
    bid.accepted = true;
    await bid.save();

    // Update gig assignment if needed
    bid.gig_id.assigned_bid = bid._id;
    await bid.gig_id.save();

    res.json({ message: 'Bid accepted', bidId: bid._id });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// Deny a bid (gig owner only)
exports.denyBid = async (req, res) => {
  try {
    const { bidId } = req.params;
    const userId = req.user.userId;
    const bid = await Bid.findById(bidId).populate('gig_id');
    if (!bid) return res.status(404).json({ error: 'Bid not found' });

    if (bid.gig_id.user_id.toString() !== userId) {
      return res.status(403).json({ error: 'Only gig owner can deny bids' });
    }

    // Mark bid as rejected instead of deleting
    bid.rejected = true;
    await bid.save();

    // Optionally, remove related conversation or mark it inactive
    // For example:
    // await Conversation.findOneAndDelete({ gig_id: bid.gig_id._id, bidder_id: bid.user_id });

    res.json({ message: 'Bid denied', bidId });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// Optional undeny endpoint to revert a rejection
exports.undenyBid = async (req, res) => {
  try {
    const { bidId } = req.params;
    const userId = req.user.userId;
    const bid = await Bid.findById(bidId).populate('gig_id');
    if (!bid) return res.status(404).json({ error: 'Bid not found' });

    if (bid.gig_id.user_id.toString() !== userId) {
      return res.status(403).json({ error: 'Only gig owner can undeny bids' });
    }

    bid.rejected = false;
    await bid.save();

    res.json({ message: 'Bid undenied', bidId });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.getMyBids = async (req, res) => {
  try {
    const userId = req.user.userId;
    const bids = await Bid.find({ 
      user_id: userId,
      gig_id: { $exists: true } // Add this filter
    })
    .populate({
      path: 'gig_id',
      select: 'title description price user_id',
      match: { _id: { $exists: true } } // Ensure gig exists
    })
    .populate('user_id', 'name profile_pic_url rating')
    .exec();

    // Filter out bids where gig_id was populated as null
    const validBids = bids.filter(bid => bid.gig_id !== null);
    
    res.json(validBids);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// Add to bidController.js
exports.deleteBid = async (req, res) => {
  try {
    const { bidId } = req.params;
    const userId = req.user.userId;
    
    const bid = await Bid.findById(bidId);
    if (!bid) return res.status(404).json({ error: 'Bid not found' });

    if (bid.user_id.toString() !== userId) {
      return res.status(403).json({ error: 'Only bid creator can delete' });
    }

    await Bid.deleteOne({ _id: bidId });
    res.json({ message: 'Bid deleted successfully' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.updateBidStatus = async (req, res) => {
  try {
    const { bidId } = req.params;
    const { status } = req.body;
    const userId = req.user.userId;

    const bid = await Bid.findById(bidId).populate('gig_id');
    if (!bid) return res.status(404).json({ error: 'Bid not found' });

    if (bid.gig_id.user_id.toString() !== userId) {
      return res.status(403).json({ error: 'Only gig owner can update status' });
    }

    bid.status = status; // Add status field to Bid model
    await bid.save();
    
    res.json({ message: 'Bid status updated', bid });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

--- controllers\bookmarkController.js ---
const Bookmark = require('../models/Bookmark');
const Gig = require('../models/Gig');

exports.checkBookmarkStatus = async (req, res) => {
  try {
    const { gigId } = req.params;
    const userId = req.user.userId;

    const bookmark = await Bookmark.findOne({
      user_id: userId,
      gig_id: gigId
    });

    res.json({ isBookmarked: !!bookmark });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.toggleBookmark = async (req, res) => {
  try {
    const { gigId } = req.params;
    const userId = req.user.userId;

    // Check if gig exists
    const gig = await Gig.findById(gigId);
    if (!gig) {
      return res.status(404).json({ error: 'Gig not found' });
    }

    const existingBookmark = await Bookmark.findOne({
      user_id: userId,
      gig_id: gigId
    });

    if (existingBookmark) {
      await Bookmark.deleteOne({ _id: existingBookmark._id });
      return res.json({ isBookmarked: false });
    }

    const newBookmark = new Bookmark({
      user_id: userId,
      gig_id: gigId
    });

    await newBookmark.save();
    res.json({ isBookmarked: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.getUserBookmarks = async (req, res) => {
  try {
    const bookmarks = await Bookmark.find({ user_id: req.user.userId })
      .populate({
        path: 'gig_id',
        populate: {
          path: 'user_id',
          select: 'name profile_pic_url'
        }
      })
      .sort({ created_at: -1 });

    res.json(bookmarks);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

--- controllers\gigController.js ---
const Gig = require('../models/Gig');
const Bid = require('../models/Bid');
const Attachment = require('../models/Attachment');
const { processImage } = require('../middlewares/upload');
const { findZipcodesWithinWithDistance } = require('../services/zipcodeService');
const fs = require('fs').promises;
const sanitize = require('mongo-sanitize');

exports.getAllGigs = async (req, res) => {
  try {
    const {
      searchTerm = '',
      category = 'All',
      sortBy = 'date_desc',
      page = 1,
      limit = 20,
      zipCode,
      distance,
      minBudget,
      maxBudget,
      isVolunteer,
      serviceOffered,
      tags,
    } = req.query;

    const filter = {};

    // Search by text (title or description)
    if (searchTerm) {
      filter.$text = { $search: searchTerm };
    }

    // Filter by category
    if (category && category !== 'All') {
      filter.category = category;
    }

    if (serviceOffered !== undefined) {
      filter.service_offered = serviceOffered === 'true';
    }

    // Filter by tags (array of strings)
    if (tags) {
      filter.tags = { $in: tags.split(',') };
    }

    // Filter by volunteer status
    if (isVolunteer !== undefined) {
      filter.is_volunteer = isVolunteer === 'true';
    }

    // Filter by budget range
    if (minBudget && maxBudget) {
      filter.calculated_average_budget = {
        $gte: parseFloat(minBudget),
        $lte: parseFloat(maxBudget),
      };
    } else if (minBudget) {
      filter.calculated_average_budget = { $gte: parseFloat(minBudget) };
    } else if (maxBudget) {
      filter.calculated_average_budget = { $lte: parseFloat(maxBudget) };
    }

    // Filter by zipcode and distance
    let distanceMap = {};
    if (zipCode && distance) {
      try {
        const nearbyZipsWithDistance = await findZipcodesWithinWithDistance(
          zipCode,
          parseFloat(distance)
        );
        filter.zipcode = { $in: nearbyZipsWithDistance.map((nz) => nz.zip) };
        nearbyZipsWithDistance.forEach((nz) => {
          distanceMap[nz.zip] = nz.distance;
        });
      } catch (error) {
        console.error('Error fetching nearby zip codes:', error);
      }
    }

    // Sorting criteria
    let sortCriteria;
    if (searchTerm) {
      sortCriteria = { score: { $meta: 'textScore' } };
    } else {
      switch (sortBy) {
        case 'price_asc':
          sortCriteria = { calculated_average_budget: 1 };
          break;
        case 'price_desc':
          sortCriteria = { calculated_average_budget: -1 };
          break;
        case 'date_asc':
          sortCriteria = { created_at: 1 };
          break;
        case 'date_desc':
        default:
          sortCriteria = { created_at: -1 };
          break;
      }
    }

    // Pagination
    const pageNum = parseInt(page, 10);
    const limitNum = parseInt(limit, 10);
    const skip = (pageNum - 1) * limitNum;

    // Query gigs with filters, sorting, and pagination
    let query = Gig.find(filter)
      .populate('user_id', 'name profile_pic_url')
      .skip(skip)
      .limit(limitNum);

    if (searchTerm) {
      query = query.sort(sortCriteria).select({ score: { $meta: 'textScore' } });
    } else {
      query = query.sort(sortCriteria);
    }

    // Execute queries in parallel
    const [gigs, total] = await Promise.all([
      query.exec(),
      Gig.countDocuments(filter),
    ]);

    // Fetch attachments for gigs
    const gigIds = gigs.map((gig) => gig._id);
    const attachments = await Attachment.find({
      type: 'gig',
      foreign_key_id: { $in: gigIds },
    });

    const attachmentsByGigId = {};
    attachments.forEach((att) => {
      attachmentsByGigId[att.foreign_key_id] = att;
    });

    // Add attachments and distance to gigs
    const gigsWithAttachments = gigs.map((gig) => {
      const gigObj = gig.toObject();
      gigObj.attachment = attachmentsByGigId[gig._id] || null;
      if (distanceMap[gig.zipcode]) {
        gigObj.distance = distanceMap[gig.zipcode];
      }
      return gigObj;
    });

    // Aggregate bid counts for all fetched gigs
    const bidsAgg = await Bid.aggregate([
      { $match: { gig_id: { $in: gigIds } } },
      { $group: { _id: '$gig_id', count: { $sum: 1 } } },
    ]);

    const bidCountMap = {};
    bidsAgg.forEach((b) => {
      bidCountMap[b._id.toString()] = b.count;
    });

    // Add bid count to gigs
    gigsWithAttachments.forEach((gig) => {
      gig.bidCount = bidCountMap[gig._id.toString()] || 0;
    });

    return res.json({ gigs: gigsWithAttachments, total });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};


exports.createGig = async (req, res) => {
  try {
    const {
      title,
      description,
      category,
      zipcode,
      start_date,
      completion_date,
      team_size,
      gig_tasks: gigTasksRaw,
      budget_range_min,
      budget_range_max,
      is_volunteer: isVolunteerString,
      service_offered: serviceOfferedString, // Add this line
      tags,
    } = req.body;

    const userId = req.user.userId;

    // Convert string boolean to actual boolean
    const is_volunteer = isVolunteerString === 'true';
    const service_offered = serviceOfferedString === 'true'; // Add this line

    // Parse gig tasks from JSON string
    let gig_tasks = [];
    if (gigTasksRaw) {
      try {
        gig_tasks = JSON.parse(gigTasksRaw);
        if (!Array.isArray(gig_tasks)) {
          return res.status(400).json({ error: 'Gig tasks must be an array' });
        }
      } catch (err) {
        return res.status(400).json({ error: 'Invalid gig tasks format' });
      }
    }

    // Validate budget fields if not a volunteer gig
    if (!is_volunteer) {
      if (!budget_range_min || !budget_range_max) {
        return res.status(400).json({ error: 'Budget range is required for non-volunteer gigs' });
      }
      if (isNaN(budget_range_min) || isNaN(budget_range_max)) {
        return res.status(400).json({ error: 'Budget range must be valid numbers' });
      }
      if (parseFloat(budget_range_min) > parseFloat(budget_range_max)) {
        return res.status(400).json({ error: 'Budget range min must be less than or equal to max' });
      }
    }

    // Calculate average budget if not a volunteer gig
    const calculated_average_budget = is_volunteer
      ? null
      : (parseFloat(budget_range_min) + parseFloat(budget_range_max)) / 2;

    // Create gig object
    const gig = new Gig({
      user_id: userId,
      title,
      description,
      category,
      zipcode,
      service_offered, // Add this line
      start_date: start_date || null,
      completion_date: completion_date || null,
      team_size: team_size || 1,
      gig_tasks,
      budget_range_min: is_volunteer ? null : parseFloat(budget_range_min),
      budget_range_max: is_volunteer ? null : parseFloat(budget_range_max),
      calculated_average_budget,
      is_volunteer,
      tags: tags ? tags.split(',') : [],
    });

    // Save gig to database
    await gig.save();

    // Handle attachment if file is uploaded
    if (req.file) {
      try {
        const isImage = req.file.mimetype.startsWith('image/');
        if (isImage) {
          await processImage(req.file.path);
        }

        const stats = await fs.stat(req.file.path);
        
        await Attachment.create({
          type: 'gig',
          foreign_key_id: gig._id,
          file_url: `/uploads/${req.file.filename}`,
          uploaded_by: userId,
          mime_type: isImage ? 'image/webp' : req.file.mimetype,
          file_size: stats.size
        });
      } catch (error) {
        console.error('Error handling attachment:', error);
        return res.status(500).json({ error: 'Failed to process attachment' });
      }
    }

    return res.status(201).json({ message: 'Gig created', gigId: gig._id });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};

exports.getGigDetails = async (req, res) => {
  try {
    const { gigId } = req.params;
    const gig = await Gig.findById(gigId).populate('user_id', 'name');
    if (!gig) {
      return res.status(404).json({ error: 'Gig not found' });
    }

    const attachments = await Attachment.find({ type: 'gig', foreign_key_id: gigId });
    return res.json({ gig, attachments });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};

exports.getMyGigs = async (req, res) => {
  try {
    const userId = req.user.userId;
    const gigs = await Gig.find({ user_id: userId }).sort({ created_at: -1 });
    return res.json(gigs);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};

exports.updateGig = async (req, res) => {
  try {
    const { gigId } = req.params;
    const userId = req.user.userId;

    const gig = await Gig.findById(gigId);
    if (!gig) return res.status(404).json({ error: 'Gig not found' });
    if (gig.user_id.toString() !== userId) return res.status(403).json({ error: 'Forbidden' });

    // Handle volunteer status first
    const isVolunteer = req.body.is_volunteer === 'true';
    gig.is_volunteer = isVolunteer;

    // Reset budget fields for volunteer gigs
    if (isVolunteer) {
      gig.budget_range_min = null;
      gig.budget_range_max = null;
      gig.calculated_average_budget = null;
    } else {
      // Validate and set budget for paid gigs
      const min = parseFloat(req.body.budget_range_min);
      const max = parseFloat(req.body.budget_range_max);

      if (isNaN(min) || isNaN(max) || min < 0 || max < 0 || min > max) {
        return res.status(400).json({ error: 'Invalid budget range' });
      }

      gig.budget_range_min = min;
      gig.budget_range_max = max;
      gig.calculated_average_budget = (min + max) / 2;
    }

    // Update other fields
    gig.title = req.body.title || gig.title;
    gig.description = req.body.description || gig.description;
    gig.category = req.body.category || gig.category;
    gig.zipcode = req.body.zipcode || gig.zipcode;
    gig.start_date = req.body.start_date || null;
    gig.completion_date = req.body.completion_date || null;
    gig.team_size = parseInt(req.body.team_size) || 1;

    // Handle tasks
    try {
      gig.gig_tasks = req.body.gig_tasks ? JSON.parse(req.body.gig_tasks) : [];
    } catch (e) {
      return res.status(400).json({ error: 'Invalid tasks format' });
    }

    // Handle tags
    gig.tags = req.body.tags ? 
      req.body.tags.split(',').map(t => t.trim()).filter(t => t) : 
      [];

    // Handle file upload
    if (req.file) {
      try {
        const isImage = req.file.mimetype.startsWith('image/');
        if (isImage) {
          await processImage(req.file.path);
        }

        const stats = await fs.stat(req.file.path);

        await Attachment.deleteMany({ type: 'gig', foreign_key_id: gigId });
        await Attachment.create({
          type: 'gig',
          foreign_key_id: gigId,
          file_url: `/uploads/${req.file.filename}`,
          uploaded_by: req.user._id,
          mime_type: isImage ? 'image/webp' : req.file.mimetype,
          file_size: stats.size
        });
      } catch (error) {
        console.error('Error handling attachment:', error);
        return res.status(500).json({ error: 'Failed to process attachment' });
      }
    }

    const updatedGig = await gig.save();
    res.json({ message: 'Gig updated successfully', gig: updatedGig });

  } catch (err) {
    console.error('Update error:', err);
    res.status(500).json({ error: 'Server error during update' });
  }
};
exports.deleteGig = async (req, res) => {
  try {
    const { gigId } = req.params;
    const userId = req.user.userId;

    const gig = await Gig.findById(gigId);
    if (!gig) {
      return res.status(404).json({ error: 'Gig not found' });
    }
    if (gig.user_id.toString() !== userId) {
      return res.status(403).json({ error: 'Forbidden' });
    }

    // Delete gig and attachments
    await Gig.findByIdAndDelete(gigId);
    await Attachment.deleteMany({ type: 'gig', foreign_key_id: gigId });

    return res.json({ message: 'Gig deleted' });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};



--- controllers\leaderboardController.js ---
const User = require('../models/User'); // Add this import at the top

// controllers/leaderboardController.js
exports.getLeaderboard = async (req, res) => {
    try {
      const { timeframe } = req.query;
      
      let dateFilter = {};
      if (timeframe === 'weekly') {
        dateFilter = { updatedAt: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } };
      } else if (timeframe === 'monthly') {
        dateFilter = { updatedAt: { $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } };
      }
  
      const users = await User.aggregate([
        { $match: dateFilter },
        { $sort: { xp: -1 } },
        { $project: { name: 1, profile_pic_url: 1, xp: 1, badges: 1 } },
        { $limit: 100 }
      ]);
  
      // Add ranks
      const rankedUsers = users.map((user, index) => ({
        ...user,
        rank: index + 1
      }));
  
      res.json(rankedUsers);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: 'Server error' });
    }
  };

--- controllers\messageController.js ---
// controllers/messageController.js
const { getIO } = require('../utils/socketIOInstance');
const Conversation = require('../models/Conversation');
const Message = require('../models/Message');
const User = require('../models/User');
const Gig = require('../models/Gig');
const Bid = require('../models/Bid');
const mongoose = require('mongoose');
// We'll emit to socket.io from within these methods:
const Notification = require('../models/Notification');
// We'll create a shared instance

// GET /api/messages (all conversations for user)
exports.getAllConversationsForUser = async (req, res) => {
  try {
    const userId = req.user.userId;
    const conversations = await Conversation.find({
      $or: [
        { gig_owner_id: userId },
        { bidder_id: userId }
      ]
    })
      .sort({ created_at: -1 })
      .lean();

    // Populate conversation data
    for (let conv of conversations) {
      const gig = await Gig.findById(conv.gig_id).lean();
      conv.gigTitle = gig ? gig.title : 'No Title';

      const otherUserId = (conv.gig_owner_id.toString() === userId)
        ? conv.bidder_id
        : conv.gig_owner_id;
      const otherUser = await User.findById(otherUserId).lean();
      conv.otherUserName = otherUser?.name || 'Unknown User';
      conv.otherUserPic = otherUser?.profile_pic_url || '';
      conv.otherUserId = otherUserId.toString();
      conv.gigId = conv.gig_id.toString();
      conv.otherUserPic = otherUser?.profile_pic_url || '';

      // Mark if conversation is blocked for the current user
      if (conv.gig_owner_id.toString() === userId && conv.blocked_by_owner) {
        conv.isBlocked = true;
      } else if (conv.bidder_id.toString() === userId && conv.blocked_by_bidder) {
        conv.isBlocked = true;
      } else {
        conv.isBlocked = false;
      }
    }

    res.json(conversations);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// GET /api/messages/:conversationId
exports.getConversationMessages = async (req, res) => {
  try {
    const { conversationId } = req.params;
    const userId = req.user.userId;

    const conversation = await Conversation.findById(conversationId);
    if (!conversation) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    // Check if user is part of this conversation
    if (
      conversation.gig_owner_id.toString() !== userId &&
      conversation.bidder_id.toString() !== userId
    ) {
      return res.status(403).json({ error: 'Not allowed' });
    }

    // Check if user has blocked conversation
    if (
      (conversation.gig_owner_id.toString() === userId && conversation.blocked_by_owner) ||
      (conversation.bidder_id.toString() === userId && conversation.blocked_by_bidder)
    ) {
      return res.json([]); // Return empty if blocked from own side
    }

    const msgs = await Message.find({ conversation_id: conversationId })
      .sort({ created_at: 1 })
      .lean();

    res.json(msgs);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.sendMessage = async (req, res) => {
  try {
    const { conversationId, content, file_url } = req.body;

    if (!conversationId) {
      return res.status(400).json({ error: 'Missing conversationId' });
    }

    const userId = req.user.userId;

    // Fetch the sender's details
    const sender = await User.findById(userId);
    if (!sender) {
      return res.status(404).json({ error: 'Sender not found' });
    }

    const conversation = await Conversation.findById(conversationId).populate('gig_owner_id bidder_id');
    if (!conversation) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    // Check if the user is part of the conversation
    if (
      conversation.gig_owner_id._id.toString() !== userId &&
      conversation.bidder_id._id.toString() !== userId
    ) {
      return res.status(403).json({ error: 'Not part of this conversation' });
    }

    // Check if the conversation is blocked
    if (
      (conversation.gig_owner_id._id.toString() === userId && conversation.blocked_by_owner) ||
      (conversation.bidder_id._id.toString() === userId && conversation.blocked_by_bidder)
    ) {
      return res.status(403).json({ error: 'Conversation blocked' });
    }

    // Create and save the new message
    const newMsg = new Message({
      conversation_id: conversationId,
      sender_id: userId,
      content,
      file_url,
    });
    await newMsg.save();

    // Emit the new message to the conversation room with sender details
    const io = getIO();
    io.to(conversationId).emit('newMessage', {
      _id: newMsg._id.toString(),
      conversation_id: newMsg.conversation_id.toString(),
      sender_id: newMsg.sender_id.toString(),
      content: newMsg.content,
      file_url: newMsg.file_url,
      created_at: newMsg.created_at,
      // Additional sender info
      sender_name: sender.name,
      sender_pic: sender.profile_pic_url,
    });

    // Determine the recipient of the message
    const recipientId = conversation.gig_owner_id._id.toString() === userId
      ? conversation.bidder_id._id
      : conversation.gig_owner_id._id;

    // Create a notification for the recipient
    const notification = new Notification({
      user_id: recipientId,
      type: 'message',
      message: `You have a new message from ${sender.name}`,
      link: `/messages/${conversationId}`,
    });
    await notification.save();

    // Emit the notification to the recipient
    io.to(recipientId.toString()).emit('newNotification', notification);

    return res.status(201).json({ message: 'Message sent', newMsg });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Server error' });
  }
};


// In the deleteMessage function
exports.deleteMessage = async (req, res) => {
  try {
    const { messageId } = req.params;
    const userId = req.user.userId;

    const msg = await Message.findById(messageId);
    if (!msg) {
      return res.status(404).json({ error: 'Message not found' });
    }
    // Only sender can delete
    if (msg.sender_id.toString() !== userId) {
      return res.status(403).json({ error: 'Cannot delete others messages' });
    }

    await Message.deleteOne({ _id: messageId });

    // Use getIO() instead of direct io
    const io = getIO();
    io.to(msg.conversation_id.toString()).emit('messageDeleted', { messageId });

    res.json({ message: 'Message deleted' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// POST /api/messages/:messageId/report
exports.reportMessage = async (req, res) => {
  try {
    const { messageId } = req.params;
    const msg = await Message.findById(messageId);
    if (!msg) {
      return res.status(404).json({ error: 'Message not found' });
    }
    msg.reported = true;
    await msg.save();
    res.json({ message: 'Message reported' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// POST /api/messages/:conversationId/block
exports.blockConversation = async (req, res) => {
  try {
    const { conversationId } = req.params;
    const userId = req.user.userId;

    const conversation = await Conversation.findById(conversationId);
    if (!conversation) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    if (conversation.gig_owner_id.toString() === userId) {
      conversation.blocked_by_owner = true;
    } else if (conversation.bidder_id.toString() === userId) {
      conversation.blocked_by_bidder = true;
    } else {
      return res.status(403).json({ error: 'Not part of this conversation' });
    }

    await conversation.save();
    res.json({ message: 'Conversation blocked' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// POST /api/messages/:conversationId/unblock
exports.unblockConversation = async (req, res) => {
  try {
    const { conversationId } = req.params;
    const userId = req.user.userId;

    const conversation = await Conversation.findById(conversationId);
    if (!conversation) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    if (conversation.gig_owner_id.toString() === userId) {
      conversation.blocked_by_owner = false;
    } else if (conversation.bidder_id.toString() === userId) {
      conversation.blocked_by_bidder = false;
    } else {
      return res.status(403).json({ error: 'Not part of this conversation' });
    }

    await conversation.save();
    res.json({ message: 'Conversation unblocked' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.deleteConversation = async (req, res) => {
  try {
    const { conversationId } = req.params;
    await Conversation.findByIdAndDelete(conversationId);
    res.json({ message: 'Conversation deleted' });
  } catch (err) {
    res.status(500).json({ error: 'Server error' });
  }
};


--- controllers\notificationController.js ---
// controllers/notificationController.js
const Notification = require('../models/Notification');

// Get all notifications for a user
exports.getNotifications = async (req, res) => {
  try {
    const userId = req.user.userId;
    const notifications = await Notification.find({ user_id: userId })
      .sort({ created_at: -1 }) // Sort by most recent first
      .limit(50); // Limit to 50 notifications
    res.json(notifications);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// Mark a notification as read
exports.markAsRead = async (req, res) => {
  try {
    const { notificationId } = req.params;
    const notification = await Notification.findByIdAndUpdate(
      notificationId,
      { read: true },
      { new: true }
    );
    if (!notification) {
      return res.status(404).json({ error: 'Notification not found' });
    }
    res.json({ message: 'Notification marked as read', notification });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// Mark all notifications as read
exports.markAllAsRead = async (req, res) => {
  try {
    const userId = req.user.userId;
    await Notification.updateMany(
      { user_id: userId, read: false },
      { read: true }
    );
    res.json({ message: 'All notifications marked as read' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// Delete a notification
exports.deleteNotification = async (req, res) => {
  try {
    const { notificationId } = req.params;
    await Notification.findByIdAndDelete(notificationId);
    res.json({ message: 'Notification deleted' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

--- controllers\reportController.js ---
// controllers/reportController.js
const Report = require('../models/Report');

exports.createReport = async (req, res) => {
  try {
    const { reporterId, creatorId, contentId, contentType, reportReason, reportDetails, additionalInfo } = req.body;

    if (!reportReason || !reportDetails) {
      return res.status(400).json({ error: 'Reason and details are required.' });
    }

    const newReport = new Report({
      reporterId,
      creatorId,
      contentId,
      contentType,
      reportReason,
      reportDetails,
      additionalInfo,
    });

    await newReport.save();

    res.status(201).json({ message: 'Report submitted successfully.' });
  } catch (error) {
    console.error('Error submitting report:', error);
    res.status(500).json({ error: 'Failed to submit report.' });
  }
};

exports.getReports = async (req, res) => {
  try {
    const reports = await Report.find().populate('reporterId', 'name').populate('creatorId', 'name');
    res.status(200).json(reports);
  } catch (error) {
    console.error('Error fetching reports:', error);
    res.status(500).json({ error: 'Failed to fetch reports.' });
  }
};

exports.getReportById = async (req, res) => {
  try {
    const { id } = req.params;
    const report = await Report.findById(id).populate('reporterId', 'name').populate('creatorId', 'name');

    if (!report) {
      return res.status(404).json({ error: 'Report not found.' });
    }

    res.status(200).json(report);
  } catch (error) {
    console.error('Error fetching report:', error);
    res.status(500).json({ error: 'Failed to fetch report.' });
  }
};


--- controllers\reviewController.js ---
const Review = require('../models/Review');
const User = require('../models/User');

// Get reviews for a specific user
exports.getReviewsByUser = async (req, res) => {
  try {
    const { userId } = req.params;
    const reviews = await Review.find({ user_id: userId })
      .populate('reviewer_id', 'name profile_pic_url')  // Ensure this line is present
      .sort({ date: -1 });
    res.json(reviews);
  } catch (err) {
    res.status(500).json({ error: 'Server error' });
  }
};
// Create a new review for a user
exports.createReview = async (req, res) => {
  try {
    const { userId } = req.params;
    const reviewerId = req.user.userId; // assumes authentication middleware sets req.user

    // Verify user and reviewer exist
    const user = await User.findById(userId);
    const reviewer = await User.findById(reviewerId);
    if (!user || !reviewer) {
      return res.status(404).json({ error: 'User or reviewer not found' });
    }

    const { rating, comment } = req.body;
    if (!rating || !comment) {
      return res.status(400).json({ error: 'Rating and comment are required' });
    }

    const newReview = new Review({
      user_id: userId,
      reviewer_id: reviewerId,
      rating,
      comment
    });

    await newReview.save();
    res.status(201).json(newReview);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// Update a review by its ID (optional - if reviews are editable)
exports.updateReview = async (req, res) => {
  try {
    const { reviewId } = req.params;
    const reviewerId = req.user.userId;

    // Only allow the original reviewer to update
    const review = await Review.findById(reviewId);
    if (!review) return res.status(404).json({ error: 'Review not found' });
    if (review.reviewer_id.toString() !== reviewerId) {
      return res.status(403).json({ error: 'Forbidden' });
    }

    const { rating, comment } = req.body;
    if (rating !== undefined) review.rating = rating;
    if (comment !== undefined) review.comment = comment;
    review.date = new Date();
    
    await review.save();
    res.json(review);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

// Delete a review (optional)
exports.deleteReview = async (req, res) => {
  try {
    const { reviewId } = req.params;
    const reviewerId = req.user.userId;

    const review = await Review.findById(reviewId);
    if (!review) return res.status(404).json({ error: 'Review not found' });
    if (review.reviewer_id.toString() !== reviewerId) {
      return res.status(403).json({ error: 'Forbidden' });
    }

    await review.remove();
    res.json({ message: 'Review deleted' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};


--- controllers\userController.js ---
const User = require('../models/User');
const { resizeImage } = require('../middlewares/upload');
const path = require('path');
const fs = require('fs');

// Get public profile by userId
exports.getPublicProfile = async (req, res) => {
  try {
    const user = await User.findById(req.params.userId).select('-password');
    if (!user) return res.status(404).json({ error: 'User not found' });
    res.json(user);
  } catch (err) {
    res.status(500).json({ error: 'Server error' });
  }
};

exports.checkBlockStatus = async (req, res) => {
  try {
    const { userId } = req.params;
    const currentUser = await User.findById(req.user.userId);
    
    const isBlocked = currentUser.blockedUsers.includes(userId);
    res.json({ isBlocked });
  } catch (err) {
    res.status(500).json({ error: 'Server error' });
  }
};

exports.uploadCertifications = async (req, res) => {
  try {
    const { userId } = req.params;
    const files = req.files;

    const fileUrls = files.map((file) => `/uploads/${file.filename}`);
    const user = await User.findByIdAndUpdate(
      userId,
      { $push: { certifications: { $each: fileUrls } } },
      { new: true }
    );

    res.json(user);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.updateProfile = async (req, res) => {
  try {
    const { userId } = req.params;
    const {
      name,
      bio,
      location,
      experience,
      socialLinks,
      tagline,
      skills
    } = req.body;

    if (req.user.userId !== userId) {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    const updateData = {
      name,
      bio,
      location,
      experience: Math.max(0, parseInt(experience)) || 0,
      tagline,
      skills: Array.isArray(skills) ? skills : [],
      social_media_links: Array.isArray(socialLinks) ? socialLinks : []
    };

    const user = await User.findByIdAndUpdate(userId, updateData, {
      new: true,
    }).select('-password');

    res.json(user);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.uploadPortfolio = async (req, res) => {
  try {
    const { userId } = req.params;
    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ error: 'No files uploaded' });
    }

    const processedFiles = await Promise.all(
      req.files.map(async (file) => {
        await resizeImage(file.path, 1200, 800);
        return `/uploads/${file.filename}`;
      })
    );

    const user = await User.findByIdAndUpdate(
      userId,
      { $push: { portfolio: { $each: processedFiles } } },
      { new: true, select: '-password' }
    );

    res.json(user);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.removePortfolioItem = async (req, res) => {
  try {
    const { userId } = req.params;
    const { fileUrl } = req.body;

    // Delete physical file
    const filePath = path.join(__dirname, '..', fileUrl);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }

    const user = await User.findByIdAndUpdate(
      userId,
      { $pull: { portfolio: fileUrl } },
      { new: true, select: '-password' }
    );

    res.json(user);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.deleteProfilePicture = async (req, res) => {
  try {
    const { userId } = req.params;
    
    if (req.user.userId !== userId) {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    const user = await User.findById(userId);
    if (!user.profile_pic_url) {
      return res.status(400).json({ error: 'No profile picture to delete' });
    }

    // Delete file from filesystem
    const filePath = path.join(__dirname, '..', user.profile_pic_url);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }

    user.profile_pic_url = null;
    await user.save();
    
    res.json({ message: 'Profile picture deleted', user });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.addSocialLink = async (req, res) => {
  try {
    const { userId } = req.params;
    const { type, url } = req.body;

    if (req.user.userId !== userId) {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    const user = await User.findById(userId);
    user.social_media_links.push({ type, url });
    await user.save();
    
    res.json({ 
      message: 'Social link added', 
      links: user.social_media_links 
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

exports.deleteSocialLink = async (req, res) => {
  try {
    const { userId, index } = req.params;

    if (req.user.userId !== userId) {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    const user = await User.findById(userId);
    if (index < 0 || index >= user.social_media_links.length) {
      return res.status(400).json({ error: 'Invalid link index' });
    }

    user.social_media_links.splice(index, 1);
    await user.save();
    
    res.json({ 
      message: 'Social link deleted', 
      links: user.social_media_links 
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
};

--- middlewares\auth.js ---
// middlewares/auth.js
const jwt = require('jsonwebtoken');

exports.authenticate = (req, res, next) => {
  const token = req.cookies.token;
  console.log('Received token:', token); // Debug logging

  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    console.log('Decoded token:', decoded); // Debug logging
    req.user = decoded;
    next();
  } catch (err) {
    console.error('JWT verification error:', err.message);
    return res.status(403).json({ error: 'Invalid token' });
  }
};


exports.authorizeProfileUpdate = (req, res, next) => {
  if (req.params.userId !== req.user.userId) {
    return res.status(403).json({ error: 'Unauthorized profile access' });
  }
  next();
};

--- middlewares\upload.js ---
// middlewares/upload.js
const multer = require('multer');
const sharp = require('sharp');
const path = require('path');
const fs = require('fs').promises;
const crypto = require('crypto');

const generateSafeName = bytes => 
  crypto.randomBytes(bytes).toString('hex');

const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = 'uploads/';
    await fs.mkdir(uploadDir, { recursive: true });
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    const filename = `${generateSafeName(16)}${ext}`;
    cb(null, filename);
  }
});

const fileTypeValidations = {
  profile: {
    mime: /^image\/(jpeg|png|webp)$/,
    ext: /\.(jpe?g|png|webp)$/i,
    maxSize: 2 * 1024 * 1024 // 2MB
  },
  general: {
    mime: /^(image|application\/pdf|text\/plain)/,
    ext: /\.(jpe?g|png|pdf|txt)$/i,
    maxSize: 5 * 1024 * 1024 // 5MB
  }
};

const fileFilter = (req, file, cb) => {
  try {
    const fileType = req.body.type === 'profile' ? 'profile' : 'general';
    const { mime, ext, maxSize } = fileTypeValidations[fileType];

    if (!mime.test(file.mimetype) || !ext.test(file.originalname)) {
      return cb(new Error('Invalid file type'), false);
    }

    if (file.size > maxSize) {
      return cb(new Error('File size exceeds limit'), false);
    }

    cb(null, true);
  } catch (err) {
    cb(err, false);
  }
};

const messageUpload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
    files: 1
  }
});

const processImage = async (filePath) => {
  try {
    const metadata = await sharp(filePath).metadata();
    const needsResize = metadata.width > 800 || metadata.height > 800;
    
    if (needsResize) {
      await sharp(filePath)
        .resize(800, 800, { fit: 'inside', withoutEnlargement: true })
        .toFormat('webp')
        .toFile(`${filePath}.webp`);
      
      await fs.unlink(filePath);
      await fs.rename(`${filePath}.webp`, filePath);
    }

    if (metadata.format !== 'webp') {
      await sharp(filePath)
        .toFormat('webp')
        .toFile(`${filePath}.webp`);
      
      await fs.unlink(filePath);
      await fs.rename(`${filePath}.webp`, filePath);
    }
  } catch (err) {
    await fs.unlink(filePath);
    throw err;
  }
};

module.exports = {
  messageUpload,
  processImage
};

--- middlewares\validation.js ---
const { body, param } = require('express-validator');

exports.validateAttachmentUpload = [
  body('type').isIn(['gig', 'message', 'bid', 'profile', 'portfolio']),
  body('foreign_key_id').isMongoId(),
  param('attachmentId').isMongoId()
];

--- models\Attachment.js ---
// models/Attachment.js
const mongoose = require('mongoose');
const sanitize = require('mongo-sanitize');

const attachmentSchema = new mongoose.Schema({
  type: {
    type: String,
    enum: ['gig', 'message', 'bid', 'profile', 'portfolio'],
    required: true,
    index: true
  },
  foreign_key_id: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    index: true
  },
  file_url: { 
    type: String, 
    required: true,
    validate: {
      validator: v => /^\/uploads\/[a-f0-9-]+\.\w+$/.test(v),
      message: 'Invalid file URL format'
    }
  },
  uploaded_by: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  mime_type: {
    type: String,
    required: true,
    match: /^[a-z]+\/[a-z0-9-+.]+$/i
  },
  file_size: {
    type: Number,
    min: 1,
    max: 5 * 1024 * 1024 // 5MB
  },
  uploaded_at: { 
    type: Date, 
    default: Date.now,
    index: true 
  }
});

// Sanitize inputs before saving
attachmentSchema.pre('save', function(next) {
  this.type = sanitize(this.type);
  this.file_url = sanitize(this.file_url);
  next();
});

module.exports = mongoose.model('Attachment', attachmentSchema);

--- models\Bid.js ---
const mongoose = require('mongoose');

const bidSchema = new mongoose.Schema({
  gig_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Gig', required: true },
  user_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  amount: { type: Number, required: true },
  message: { type: String }, // initial message
  accepted: { type: Boolean, default: false },
  rejected: { type: Boolean, default: false },
  conversation_id: { type: mongoose.Schema.Types.ObjectId }, // Added field
  created_at: { type: Date, default: Date.now },
  status: {
    type: String,
    enum: ['pending', 'accepted', 'rejected'],
    default: 'pending'
  }
});

bidSchema.index({ gig_id: 1, user_id: 1 }, { unique: true });

module.exports = mongoose.model('Bid', bidSchema);



--- models\Bookmark.js ---
const mongoose = require('mongoose');

const bookmarkSchema = new mongoose.Schema({
  user_id: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  gig_id: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Gig',
    required: true
  },
  created_at: {
    type: Date,
    default: Date.now
  }
});

// Add compound index to ensure unique bookmarks
bookmarkSchema.index({ user_id: 1, gig_id: 1 }, { unique: true });

module.exports = mongoose.model('Bookmark', bookmarkSchema);

--- models\Conversation.js ---
const mongoose = require('mongoose');

const conversationSchema = new mongoose.Schema({
  gig_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Gig', required: true },
  gig_owner_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  bidder_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  bid_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Bid', required: true },
  blocked_by_owner: { type: Boolean, default: false },
  blocked_by_bidder: { type: Boolean, default: false },
  locked: { type: Boolean, default: false },  // Newly added field
  created_at: { type: Date, default: Date.now }
});


module.exports = mongoose.model('Conversation', conversationSchema);


--- models\Gig.js ---
const mongoose = require('mongoose');

const gigSchema = new mongoose.Schema({
  user_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  title: { type: String, required: true },
  description: { type: String, required: true },
  category: { type: String, required: true }, // Updated to string for flexibility
  zipcode: { type: String, required: true }, // Required zipcode
  start_date: { type: Date }, // Optional start date
  completion_date: { type: Date }, // Optional completion date
  created_at: { type: Date, default: Date.now }, // Automatically set
  team_size: { type: Number, default: 1 }, // Default team size is 1
  gig_tasks: { type: [String], default: [] }, // Array of tasks
  budget_range_min: { type: Number }, // Required if not volunteer
  budget_range_max: { type: Number }, // Required if not volunteer
  service_offered: { type: Boolean, default: false },
  calculated_average_budget: { 
    type: Number,
    default: null,
    validate: {
      validator: function(v) {
        // Allow null for volunteer gigs and numbers for paid gigs
        return v === null || Number.isFinite(v);
      },
      message: '{VALUE} is not a valid number or null'
    }
  },
  is_volunteer: { type: Boolean, default: false }, // Default to false
  tags: { type: [String], default: [] }, // Array of tags
 
},
{ timestamps: true });

// Index for zipcode and created_at for faster queries
gigSchema.index({ zipcode: 1 });
gigSchema.index({ created_at: -1 });
gigSchema.index({ category: 1, is_volunteer: 1, calculated_average_budget: 1 });

module.exports = mongoose.model('Gig', gigSchema);

--- models\Message.js ---
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  conversation_id: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Conversation',
    required: true
  },
  sender_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  content: { type: String, default: '' },
  file_url: { type: String, default: '' }, // If there's an attachment
  reported: { type: Boolean, default: false },
  created_at: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Message', messageSchema);


--- models\Notification.js ---
// models/Notification.js
const mongoose = require('mongoose');

const notificationSchema = new mongoose.Schema({
  user_id: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true }, // User who receives the notification
  type: { type: String, required: true, enum: ['message', 'bid'] }, // Type of notification
  message: { type: String, required: true }, // Notification message
  read: { type: Boolean, default: false }, // Whether the notification has been read
  link: { type: String }, // Optional link to redirect the user (e.g., to a message or gig)
  created_at: { type: Date, default: Date.now }, // Timestamp
});

module.exports = mongoose.model('Notification', notificationSchema);

--- models\Report.js ---
// models/Report.js
const mongoose = require('mongoose');

const reportSchema = new mongoose.Schema({
  reporterId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  creatorId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  contentId: { type: mongoose.Schema.Types.ObjectId, required: true },
  contentType: { type: String, required: true }, // "gig" or "profile"
  reportReason: { type: String, required: true }, // Dropdown value
  reportDetails: { type: String, required: true }, // User's detailed description
  additionalInfo: { type: String }, // Optional field for extra details
  timestamp: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Report', reportSchema);


--- models\Review.js ---
const mongoose = require('mongoose');

const reviewSchema = new mongoose.Schema({
  user_id: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  reviewer_id: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  rating: { 
    type: Number, 
    required: true 
  },
  comment: { 
    type: String, 
    required: true 
  },
  date: { 
    type: Date, 
    default: Date.now 
  }
});


module.exports = mongoose.model('Review', reviewSchema);


--- models\User.js ---
// models/User.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  // Personal Information
  name: { type: String, required: true },
  profile_pic_url: { type: String },
  tagline: { type: String },

  // Contact Information
  preferred_communication: { type: String, enum: ['platform', 'email', 'phone'] },
  social_media_links: { type: [String], default: [] },
  location: { type: String },
  service_area: { type: String },

  // Skills and Expertise
  services_offered: { type: [String], default: [] }, // Tags
  specializations: { type: [String], default: [] }, // Tags
  certifications: { type: [String], default: [] }, // File URLs
  blockedUsers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
  experience: { type: Number, min: 0, default: 0 },
  portfolio: [{
    type: String,
    validate: {
      validator: v => /^\/uploads\/[a-zA-Z0-9_-]+\.(jpg|jpeg|png|gif|webp)$/.test(v),
      message: 'Invalid portfolio file path'
    }
  }],
  social_media_links: [{
    type: {
      type: String,
      enum: ['github', 'linkedin', 'twitter', 'website', 'youtube'],
      required: true
    },
    url: {
      type: String,
      required: true,
    }
  }],
  skills: [{ type: String, maxlength: 50 }],

  // Availability
  working_hours: { type: String },
  calendar_link: { type: String },

  // Portfolio/Work Samples
  portfolio: { type: [String], default: [] }, // File URLs
  testimonials: { type: [String], default: [] }, // Testimonial texts

  // Reviews and Ratings
  reviews: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Review' }],
  rating: { type: Number, default: 0 },

  // Pricing and Payment Details
  rate_card: { type: String },
  payment_methods: { type: [String], default: [] },

  // About Section
  bio: { type: String },

  // Trust and Safety
  background_check: { type: Boolean, default: false },
  insurance_details: { type: String },

  // Platform-Specific Features
  response_time: { type: String },
  completed_jobs: { type: Number, default: 0 },
  verified_badges: { type: [String], default: [] },

  // Call-to-Action
  request_service_link: { type: String },
  is_favorite: { type: Boolean, default: false },

  // Additional Details
  languages_spoken: { type: [String], default: [] }, // Tags
  faqs: { type: [String], default: [] },
  disclaimers: { type: String },

  // Default Fields
  email: { type: String, unique: true, required: true },
  password: { type: String, required: true },
  created_at: { type: Date, default: Date.now },

  xp: { type: Number, default: 0 },
  badges: { type: [String], default: [] }, // Ensure default empty array
  rank: { type: Number },
  completed_gigs: { type: Number, default: 0 },

  redeemedRewards: [{ 
    rewardId: mongoose.Schema.Types.ObjectId,
    redeemedAt: Date 
  }],
  unlockedTiers: [String],

  googleId: { type: String, unique: true, sparse: true },
facebookId: { type: String, unique: true, sparse: true },
appleId: { type: String, unique: true, sparse: true },
});

module.exports = mongoose.model('User', userSchema);

--- models\Zipcode.js ---
// models/Zipcode.js
const mongoose = require('mongoose');

const zipcodeSchema = new mongoose.Schema({
  zip: { type: String, required: true, unique: true },
  location: {
    type: { type: String, enum: ['Point'], default: 'Point' },
    coordinates: { 
      type: [Number], // [longitude, latitude]
      required: true
    }
  }
});

// Create a 2dsphere index for geospatial queries
zipcodeSchema.index({ location: '2dsphere' });

module.exports = mongoose.model('Zipcode', zipcodeSchema);


--- routes\attachmentRoutes.js ---
const express = require('express');
const router = express.Router();
const {
  uploadAttachmentGeneral,
  getAttachment,
  deleteAttachment
} = require('../controllers/attachmentController');

const { authenticate } = require('../middlewares/auth');
const { messageUpload } = require('../middlewares/upload');
const { validateAttachmentUpload } = require('../middlewares/validation');

// General file upload endpoint
router.post('/', authenticate, messageUpload.single('file'), validateAttachmentUpload, uploadAttachmentGeneral);
router.get('/:attachmentId', getAttachment);
router.delete('/:attachmentId', authenticate, deleteAttachment);

module.exports = router;

--- routes\authRoutes.js ---
// routes/authRoutes.js  (Also set domain in OAuth callbacks)
const express = require('express');
const passport = require('passport');
const { registerUser, loginUser, logoutUser } = require('../controllers/authController');
const jwt = require('jsonwebtoken');

const router = express.Router();

// Email/Password
router.post('/register', registerUser);
router.post('/login', loginUser);
router.post('/logout', logoutUser);

// Helper function (remains the same)
const generateToken = (user) => {
  return jwt.sign(
    { userId: user._id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: process.env.JWT_EXPIRES_IN }
  );
};

// Facebook OAuth - DOMAIN FIX
router.get('/facebook', passport.authenticate('facebook', { scope: ['email'] }));
router.get(
  '/facebook/callback',
  passport.authenticate('facebook', { session: false }),
  (req, res) => {
    const token = generateToken(req.user);
    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 24 * 60 * 60 * 1000,
      path: '/',
      domain: '.golockedin.com', // Set the domain
    });
    res.redirect(`${process.env.FRONTEND_ORIGIN}`);
  }
);

// Google OAuth - DOMAIN FIX
router.get(
  '/google',
  passport.authenticate('google', { scope: ['profile', 'email'], prompt: 'select_account' })
);
router.get(
  '/google/callback',
  passport.authenticate('google', { session: false, failureRedirect: `${process.env.FRONTEND_ORIGIN}/login?error=google` }),
  (req, res) => {
    const token = generateToken(req.user);
    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 24 * 60 * 60 * 1000,
      path: '/',
      domain: '.golockedin.com',  // Set the domain
    });
    res.redirect(`${process.env.FRONTEND_ORIGIN}`);
  }
);

router.get('/check-session', (req, res) => {
  const token = req.cookies.token;
  if (!token) return res.json({ isAuthenticated: false });

  try {
    jwt.verify(token, process.env.JWT_SECRET);
    res.json({ isAuthenticated: true });
  } catch {
    res.json({ isAuthenticated: false });
  }
});

// Apple OAuth - DOMAIN FIX
router.post(
  '/apple',
  passport.authenticate('apple', { session: false }),
  (req, res) => {
    const token = generateToken(req.user);
    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 24 * 60 * 60 * 1000,
      path: '/',
      domain: '.golockedin.com', // Set the domain
    });
    res.redirect(`${process.env.FRONTEND_ORIGIN}`);
  }
);

module.exports = router;

--- routes\bidRoutes.js ---
// routes/bidRoutes.js
const express = require('express');
const router = express.Router();
const { authenticate } = require('../middlewares/auth');
const { 
  createBid, 
  getBidsForGig, 
  acceptBid,
  denyBid,
  getMyBids,  // MOVE THIS ROUTE UP
  undenyBid,
  deleteBid,
  updateBidStatus,
} = require('../controllers/bidController');

// Correct order of routes
router.post('/', authenticate, createBid);
router.get('/my', authenticate, getMyBids); // This should come FIRST
router.get('/:gigId', authenticate, getBidsForGig); // This comes AFTER
router.post('/:bidId/accept', authenticate, acceptBid);
router.post('/:bidId/deny', authenticate, denyBid);
router.post('/:bidId/undeny', authenticate, undenyBid);
// Add to bidRoutes.js
router.delete('/:bidId', authenticate, deleteBid);
router.patch('/:bidId/status', authenticate, updateBidStatus);

module.exports = router;

--- routes\bookmarkRoutes.js ---
const express = require('express');
const router = express.Router();
const { authenticate } = require('../middlewares/auth');
const {
  checkBookmarkStatus,
  toggleBookmark,
  getUserBookmarks
} = require('../controllers/bookmarkController');

router.get('/check/:gigId', authenticate, checkBookmarkStatus);
router.post('/toggle/:gigId', authenticate, toggleBookmark);
router.get('/user', authenticate, getUserBookmarks);

module.exports = router;

--- routes\gigRoutes.js ---
// routes/gigRoutes.js
const express = require('express');
const router = express.Router();
const { authenticate } = require('../middlewares/auth');
const { messageUpload } = require('../middlewares/upload');
const {
  getAllGigs,
  createGig,
  getGigDetails,
  getMyGigs,
  updateGig,
  deleteGig
} = require('../controllers/gigController');

// Only change the upload middleware reference
router.post('/', authenticate, messageUpload.single('gigImage'), createGig);
router.put('/:gigId', authenticate, messageUpload.single('gigImage'), updateGig);

// Rest of the file remains exactly the same
router.get('/', getAllGigs);
router.get('/:gigId', getGigDetails);
router.get('/mygigs/owner', authenticate, getMyGigs);
router.delete('/:gigId', authenticate, deleteGig);

module.exports = router;

--- routes\leaderboardRoutes.js ---
// routes/leaderboardRoutes.js
const express = require('express');
const router = express.Router();
const { getLeaderboard } = require('../controllers/leaderboardController');

router.get('/', getLeaderboard);

module.exports = router;

--- routes\messageRoutes.js ---
// routes/messageRoutes.js
const express = require('express');
const router = express.Router();
const { authenticate } = require('../middlewares/auth');
const {
  getAllConversationsForUser,
  getConversationMessages,
  sendMessage,
  deleteMessage,
  deleteConversation,
  reportMessage,
  blockConversation,
  unblockConversation
} = require('../controllers/messageController');

// GET all user conversations
router.get('/', authenticate, getAllConversationsForUser);

// GET messages for a specific conversation
router.get('/:conversationId', authenticate, getConversationMessages);

// POST a new message
router.post('/', authenticate, sendMessage);

// DELETE a specific message
router.delete('/:messageId', authenticate, deleteMessage);
router.post('/:messageId/report', authenticate, reportMessage);
router.post('/:conversationId/block', authenticate, blockConversation);
router.post('/:conversationId/unblock', authenticate, unblockConversation);
// In messageRoutes.js
router.delete('/conversation/:conversationId', authenticate, deleteConversation);


module.exports = router;


--- routes\notificationRoutes.js ---
// routes/notificationRoutes.js
const express = require('express');
const router = express.Router();
const { authenticate } = require('../middlewares/auth');
const {
  getNotifications,
  markAsRead,
  markAllAsRead,
  deleteNotification,
} = require('../controllers/notificationController');

// Get all notifications for the authenticated user
router.get('/', authenticate, getNotifications);

// Mark a notification as read
router.put('/:notificationId/read', authenticate, markAsRead);

// Mark all notifications as read
router.put('/read-all', authenticate, markAllAsRead);

// Delete a notification
router.delete('/:notificationId', authenticate, deleteNotification);

module.exports = router;

--- routes\reportRoutes.js ---
const express = require('express');
const router = express.Router();
const { authenticate } = require('../middlewares/auth');
const {
  createReport,
  getReports,
  getReportById,
} = require('../controllers/reportController');

// Route to create a new report
router.post('/', authenticate, createReport);

// Route to get all reports (admin use)
router.get('/', authenticate, getReports);

// Route to get a specific report by ID
router.get('/:id', authenticate, getReportById);

module.exports = router;


--- routes\reviewRoutes.js ---
const express = require('express');
const router = express.Router();
const { authenticate } = require('../middlewares/auth');
const reviewController = require('../controllers/reviewController');

// Get all reviews for a user
router.get('/user/:userId', reviewController.getReviewsByUser);

// Create a new review for a user (requires authentication)
router.post('/user/:userId', authenticate, reviewController.createReview);

// Update a review by id (optional, if needed)
router.put('/:reviewId', authenticate, reviewController.updateReview);

// Delete a review by id (optional, if needed)
router.delete('/:reviewId', authenticate, reviewController.deleteReview);

module.exports = router;


--- routes\userRoutes.js ---
// routes/userRoutes.js (Corrected)
const express = require('express');
const router = express.Router();
const { authenticate } = require('../middlewares/auth'); // Corrected path
const userController = require('../controllers/userController');
const User = require('../models/User'); // <---  IMPORT THE USER MODEL.  THIS WAS MISSING!

const { uploadPortfolio, uploadCertifications, updateProfile} = require('../controllers/userController');
const { messageUpload } = require('../middlewares/upload');

router.get('/me', authenticate, async (req, res) => {
    try {
      console.log("req.user:", req.user); // <--- ADD THIS for debugging

      const user = await User.findById(req.user.userId).select('-password');
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }
      res.json(user);
    } catch (error) {
      console.error(error);
      res.status(500).json({ message: 'Server error' });
    }
  });

// Public profile
router.get('/:userId', userController.getPublicProfile);

router.post('/:userId/portfolio', authenticate, messageUpload.array('portfolio'), uploadPortfolio);
router.put('/:userId/portfolio', authenticate, messageUpload.array('portfolio'), uploadPortfolio);

// Update user profile
router.put('/:userId', authenticate, userController.updateProfile);

// routes/userRoutes.js
router.post('/:userId/certifications', authenticate, messageUpload.array('certifications'), uploadCertifications);
router.put('/:userId', authenticate, updateProfile);

// In your Express routes:
router.delete('/users/:userId/portfolio', userController.removePortfolioItem);

router.get('/:userId/block-status', authenticate, userController.checkBlockStatus);

router.delete('/:userId/profile-pic', authenticate, userController.deleteProfilePicture);

// Social links routes
router.post('/:userId/social-links', authenticate, userController.addSocialLink);
router.delete('/:userId/social-links/:index', authenticate, userController.deleteSocialLink);



module.exports = router;

--- strategies\passportStrategies.js ---
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const AppleStrategy = require('passport-apple').Strategy;
const FacebookStrategy = require('passport-facebook').Strategy;
const User = require('../models/User');
const jwt = require('jsonwebtoken');

// Serialize and deserialize user if needed (here using JWT, so can be minimal)

passport.serializeUser((user, done) => done(null, user.id));
passport.deserializeUser(async (id, done) => {
  try {
    const user = await User.findById(id);
    done(null, user);
  } catch (err) {
    done(err, null);
  }
});

// Google Strategy
passport.use(
  new GoogleStrategy(
    {
      clientID: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      callbackURL: process.env.GOOGLE_CALLBACK_URL,
      proxy: true // Add this if using reverse proxy/load balancer
    },
    async (accessToken, refreshToken, profile, done) => {
      try {
        let user = await User.findOne({ 
          $or: [
            { googleId: profile.id },
            { email: profile.emails[0].value }
          ]
        });

        if (!user) {
          user = new User({
            name: profile.displayName,
            email: profile.emails[0].value,
            googleId: profile.id,
            password: ''
          });
          await user.save();
        } else if (!user.googleId) {
          user.googleId = profile.id;
          await user.save();
        }

        return done(null, user);
      } catch (err) {
        return done(err, null);
      }
    }
  )
);

passport.use(
  new FacebookStrategy(
    {
      clientID: process.env.FACEBOOK_APP_ID,
      clientSecret: process.env.FACEBOOK_APP_SECRET,
      callbackURL: process.env.FACEBOOK_CALLBACK_URL,
      profileFields: ['id', 'emails', 'name']
    },
    async (accessToken, refreshToken, profile, done) => {
      try {
        let user = await User.findOne({ facebookId: profile.id });
        if (!user) {
          user = await User.findOne({ email: profile.emails[0].value });
          if (user) {
            user.facebookId = profile.id;
          } else {
            user = new User({
              name: `${profile.name.givenName} ${profile.name.familyName}`,
              email: profile.emails[0].value,
              facebookId: profile.id,
              password: ''
            });
          }
          await user.save();
        }
        done(null, user);
      } catch (err) {
        done(err, null);
      }
    }
  )
);

// Apple Strategy
passport.use(
  new AppleStrategy(
    {
      clientID: process.env.APPLE_CLIENT_ID,
      teamID: process.env.APPLE_TEAM_ID,
      keyID: process.env.APPLE_KEY_ID,
      privateKeyString: process.env.APPLE_PRIVATE_KEY.replace(/\\n/g, '\n'),
      callbackURL: process.env.APPLE_CALLBACK_URL,
      scope: ['name', 'email']
    },
    async (accessToken, refreshToken, idToken, profile, done) => {
      try {
        // Find or create user
        let user = await User.findOne({ appleId: profile.id });
        if (!user) {
          // If email exists with another method, update record; otherwise create new.
          user = await User.findOne({ email: profile.email });
          if (user) {
            user.appleId = profile.id;
          } else {
            user = new User({
              name: profile.name ? `${profile.name.firstName} ${profile.name.lastName}` : 'Apple User',
              email: profile.email,
              appleId: profile.id,
              password: '', // no password since it's OAuth
            });
          }
          await user.save();
        }
        done(null, user);
      } catch (err) {
        done(err, null);
      }
    }
  )
);


--- utils\logger.js ---
const { createLogger, format, transports } = require('winston');
const { combine, timestamp, printf } = format;

const logFormat = printf(({ level, message, timestamp }) => {
  return `${timestamp} [${level}]: ${message}`;
});

const logger = createLogger({
  level: 'info',
  format: combine(
    timestamp(),
    logFormat
  ),
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'logs/error.log', level: 'error' }),
    new transports.File({ filename: 'logs/combined.log' })
  ]
});

module.exports = logger;

--- utils\socketHandlers.js ---
// utils/socketHandlers.js
const jwt = require('jsonwebtoken');
const cookie = require('cookie');
const Notification = require('../models/Notification');

// Store online users for notifications
let onlineUsers = {}; // { userId: socketId }

function setupSocketIO(io) {
  // Middleware to verify JWT from cookies on connection
  io.use((socket, next) => {
    console.log('Handshake cookies:', socket.handshake.headers.cookie);
    let token;
    if (socket.handshake.headers.cookie) {
      const cookies = cookie.parse(socket.handshake.headers.cookie);
      token = cookies.token;
    }
    if (!token) return next(new Error('No token provided'));
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      socket.userId = decoded.userId;
      return next();
    } catch (err) {
      return next(new Error('Invalid token'));
    }
  });

  io.on('connection', (socket) => {
    console.log('A user connected:', socket.userId);

    // Store the socket for the connected user
    onlineUsers[socket.userId] = socket.id;

    // Join the user's room for real-time notifications
    socket.join(socket.userId);

    // --- Existing Chat Functionality ---
    socket.on('joinConversation', (conversationId) => {
      // The user joins a specific conversation room
      socket.join(conversationId);
    });

    // Listen for typing indicator
    socket.on('typing', ({ conversationId }) => {
      socket.to(conversationId).emit('typing', {
        userId: socket.userId,
        conversationId,
      });
    });

    // Listen for new message
    socket.on('newMessage', (messageData) => {
      // Broadcast to all other users in the room
      socket.to(messageData.conversationId).emit('newMessage', messageData);
    });

    // --- New Notification Functionality ---
    socket.on('newNotification', (notification) => {
      // Emit the notification to the recipient using their stored socket id
      const recipientSocketId = onlineUsers[notification.user_id];
      if (recipientSocketId) {
        io.to(recipientSocketId).emit('newNotification', notification);
      }
    });

    // Cleanup on disconnect
    socket.on('disconnect', () => {
      console.log('User disconnected:', socket.userId);
      delete onlineUsers[socket.userId];
    });
  });
}

module.exports = { setupSocketIO };


--- utils\socketIOInstance.js ---
// utils/socketIOInstance.js
const { Server } = require('socket.io');
require('dotenv').config();

let io;

function init(server) {
  io = new Server(server, {
    cors: {
      origin: process.env.FRONTEND_ORIGIN,
      methods: ['GET', 'POST'],
      credentials: true
    },
    connectionStateRecovery: {
      maxDisconnectionDuration: 2 * 60 * 1000, // 2 minutes
      skipMiddlewares: true
    }
  });

  // Add ping/pong handling
  io.on('connection', (socket) => {
    socket.on('ping', (cb) => cb());
    console.log('A user connected:', socket.id);

    socket.on('disconnect', () => {
      console.log('User disconnected:', socket.id);
    });
  });

  return io;
}

function getIO() {
  if (!io) {
    throw new Error('Socket.io not initialized!');
  }
  return io;
}

module.exports = {
  init,
  getIO,
};

--- server.js ---
// server.js (Main application file) - CORS and Cookie Domain Fix
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const xss = require('xss-clean');
const rateLimit = require('express-rate-limit');
const mongoose = require('mongoose');
const path = require('path');
const passport = require('passport');
const http = require('http');
const { init } = require('./utils/socketIOInstance');
const { setupSocketIO } = require('./utils/socketHandlers');
const cookieParser = require('cookie-parser');

// Routes
const authRoutes = require('./routes/authRoutes');
const userRoutes = require('./routes/userRoutes');
const gigRoutes = require('./routes/gigRoutes');
const bidRoutes = require('./routes/bidRoutes');
const messageRoutes = require('./routes/messageRoutes');
const attachmentRoutes = require('./routes/attachmentRoutes');
const reviewRoutes = require('./routes/reviewRoutes');
const reportRoutes = require('./routes/reportRoutes');
const notificationRoutes = require('./routes/notificationRoutes');
const leaderboardRoutes = require('./routes/leaderboardRoutes');
const bookmarkRoutes = require('./routes/bookmarkRoutes');

const app = express();
app.set('trust proxy', 1);

// HTTP server + Socket.IO
const server = http.createServer(app);
const io = init(server);
setupSocketIO(io);
app.set('io', io);

// CORS Setup - Explicitly allow Cache-Control
const corsOptions = {
  origin: (origin, callback) => {
    const allowedOrigins = process.env.ALLOWED_ORIGINS.split(',');
    //console.log("Allowed Origins:", allowedOrigins);
    //console.log('hi');
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error(`Origin ${origin} not allowed`));
    }
  },
  credentials: true,
  allowedHeaders: ['Content-Type', 'Authorization', 'x-requested-with', 'Cache-Control'] // ADD 'Cache-Control' here
};
app.use(cors(corsOptions));

// Security Middlewares
app.use(helmet({
  contentSecurityPolicy: false, // Temporarily disable for testing
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
app.use(xss());

// Rate Limiting
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW, 10), // 15 minutes
  max: parseInt(process.env.RATE_LIMIT_MAX, 10)         // 100 requests
});
app.use(limiter);

// Body Parsing
app.use(express.json());
app.use(cookieParser()); // Use cookie-parser middleware

// Passport initialization
app.use(passport.initialize());

// Static Files
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// MongoDB
mongoose.connect(process.env.MONGO_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('MongoDB connected'))
.catch(err => {
  console.error('MongoDB connection error:', err);
  process.exit(1);
});

// Passport Strategies
require('./strategies/passportStrategies');

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/gigs', gigRoutes);
app.use('/api/bids', bidRoutes);
app.use('/api/messages', messageRoutes);
app.use('/api/attachments', attachmentRoutes);
app.use('/api/reviews', reviewRoutes);
app.use('/api/reports', reportRoutes);
app.use('/api/notifications', notificationRoutes);
app.use('/api/leaderboard', leaderboardRoutes);
app.use('/api/bookmarks', bookmarkRoutes);

// Start Server
const PORT = process.env.SERVER_PORT || 4000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Export for testing - Keeping this as it was in original code, assuming you still need it for tests
if (process.env.NODE_ENV === 'test') {
  module.exports = { app, server };
}
